var B={waitlist:{fields:{email:{type:"string",required:!0,input:!0},joinedAt:{type:"date",required:!0,input:!1,defaultValue:new Date}}}};var I=()=>{return{id:"waitlist",$InferServerPlugin:{}}};import{generateId as W}from"better-auth";import{z as A}from"zod";import{createAuthEndpoint as $}from"better-auth/api";import{mergeSchema as u}from"better-auth/db";var j={MAX_PARTICIPANTS_REACHED:"Maximum waitlist participants reached",USER_EXISTS:"User already exists in the waitlist"},X=(P)=>{let i={enabled:P?.enabled??!1,maximumWaitlistParticipants:P?.maximumWaitlistParticipants??null,schema:P?.schema,waitlistEndConfig:P?.waitlistEndConfig??{event:"max-signups-reached",maximumSignups:-1,onWaitlistEnd(f){}},additionalFields:P?.additionalFields??{}},w=u(B,i.schema);return w.waitlist.fields={...w.waitlist.fields,...i.additionalFields},{id:"waitlist",schema:w,$ERROR_CODES:j,endpoints:{addWaitlistUser:$("/waitlist/add-user",{method:"POST",body:z({...i.additionalFields,email:{type:"string",required:!0},name:{type:"string",required:!0}})},async(f)=>{let y=Object.keys(w)[0],{email:r,name:D,...R}=f.body;if(await f.context.adapter.findOne({model:y,where:[{field:"email",value:r,operator:"eq"}]}))throw f.error("FORBIDDEN",{message:j.USER_EXISTS});let b=null;if(i.maximumWaitlistParticipants){if(b=await f.context.adapter.count({model:y}),b>=i.maximumWaitlistParticipants)throw f.error("FORBIDDEN",{message:j.MAX_PARTICIPANTS_REACHED})}if(i.waitlistEndConfig.event==="max-signups-reached"){if(b===null)b=await f.context.adapter.count({model:y});if(b>=i.waitlistEndConfig.maximumSignups){let g=await q({ctx:f,modelName:y});i.waitlistEndConfig.onWaitlistEnd(g);return}}else if(i.waitlistEndConfig.event==="date-reached"){if(new Date>i.waitlistEndConfig.date){let g=await q({ctx:f,modelName:y});i.waitlistEndConfig.onWaitlistEnd(g);return}}else if(i.waitlistEndConfig.event==="trigger-function")i.waitlistEndConfig.triggerFunction(async()=>{let g=await q({ctx:f,modelName:y});i.waitlistEndConfig.onWaitlistEnd(g);return});let V=await f.context.adapter.create({model:y,data:{email:r,name:D,id:W(),joinedAt:new Date,...R}});return f.json(V)})}}};function z(P){let i={};for(let[w,f]of Object.entries(P)){let y;if(f.type==="string")y=A.string();else if(f.type==="number")y=A.number();else if(f.type==="boolean")y=A.boolean();else if(f.type==="date")y=A.date();else if(f.type==="string[]")y=A.array(A.string());else y=A.array(A.number());if(!f.required)y=y.optional();i[w]=y}return A.object(i)}async function q({ctx:P,modelName:i,allUserCount:w}){return w=w??await P.context.adapter.count({model:i}),await P.context.adapter.findMany({model:i,limit:w})}export{I as waitlistClient,X as waitlist,j as ERROR_CODES};

//# debugId=A8BF0837AAF6AF5164756E2164756E21
