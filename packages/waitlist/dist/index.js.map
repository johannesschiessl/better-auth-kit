{
  "version": 3,
  "sources": ["../src/schema.ts", "../src/client.ts", "../src/index.ts"],
  "sourcesContent": [
    "import type { AuthPluginSchema } from \"better-auth\";\n\nexport const schema = {\n  waitlist: {\n    fields: {\n      email: {\n        type: \"string\",\n        required: true,\n        input: true,\n      },\n      joinedAt: {\n        type: \"date\",\n        required: true,\n        input: false,\n        defaultValue: new Date(),\n      },\n    },\n  },\n} satisfies AuthPluginSchema;\n\nexport type WaitlistUser = {\n  id: string;\n  email: string;\n  name: string;\n  joinedAt: Date;\n};\n",
    "import type { BetterAuthClientPlugin } from \"better-auth\";\nimport type { waitlist } from \".\";\n\nexport const waitlistClient = () => {\n  return {\n    id: \"waitlist\",\n    $InferServerPlugin: {} as ReturnType<typeof waitlist>,\n  } satisfies BetterAuthClientPlugin;\n};\n",
    "import {\n  generateId,\n  type AuthContext,\n  type BetterAuthPlugin,\n  type EndpointContext,\n} from \"better-auth\";\nimport { z, type ZodRawShape, type ZodTypeAny } from \"zod\";\nimport type { WaitlistOptions } from \"./types\";\nimport { schema, type WaitlistUser } from \"./schema\";\nimport { createAuthEndpoint, APIError } from \"better-auth/api\";\nimport {\n  mergeSchema,\n  type FieldAttribute,\n  type InferFieldsInput,\n} from \"better-auth/db\";\nexport * from \"./types\";\nexport * from \"./client\";\n\nexport const ERROR_CODES = {\n  MAX_PARTICIPANTS_REACHED: \"Maximum waitlist participants reached\",\n  USER_EXISTS: \"User already exists in the waitlist\",\n} as const;\n\nexport const waitlist = (options?: WaitlistOptions) => {\n  const opts = {\n    enabled: options?.enabled ?? false,\n    maximumWaitlistParticipants: options?.maximumWaitlistParticipants ?? null,\n    schema: options?.schema,\n    waitlistEndConfig: options?.waitlistEndConfig ?? {\n      event: \"max-signups-reached\",\n      maximumSignups: -1,\n      onWaitlistEnd(users) {},\n    },\n    additionalFields: options?.additionalFields ?? {},\n  } satisfies WaitlistOptions;\n\n  const merged_schema = mergeSchema(schema, opts.schema);\n  merged_schema.waitlist.fields = {\n    ...merged_schema.waitlist.fields,\n    ...opts.additionalFields,\n  };\n\n  type WaitlistUserModified = WaitlistUser &\n    InferFieldsInput<typeof opts.additionalFields>;\n\n  return {\n    id: \"waitlist\",\n    schema: merged_schema,\n    $ERROR_CODES: ERROR_CODES,\n    endpoints: {\n      addWaitlistUser: createAuthEndpoint(\n        \"/waitlist/add-user\",\n        {\n          method: \"POST\",\n          body: convertAdditionalFieldsToZodSchema({\n            ...opts.additionalFields,\n            email: { type: \"string\", required: true },\n            name: { type: \"string\", required: true },\n          }) as never as z.ZodType<Omit<WaitlistUser, \"id\" | \"joinedAt\">>,\n        },\n        async (ctx) => {\n          const model = Object.keys(merged_schema)[0] as string;\n          const { email, name, ...everythingElse } = ctx.body as {\n            email: string;\n            name: string;\n          } & Record<string, any>;\n\n          const found = await ctx.context.adapter.findOne<WaitlistUserModified>(\n            {\n              model: model,\n              where: [{ field: \"email\", value: email, operator: \"eq\" }],\n            },\n          );\n\n          if (found) {\n            throw ctx.error(\"FORBIDDEN\", {\n              message: ERROR_CODES.USER_EXISTS,\n            });\n          }\n\n          let count: number | null = null;\n\n          if (opts.maximumWaitlistParticipants) {\n            count = await ctx.context.adapter.count({\n              model: model,\n            });\n\n            if (count >= opts.maximumWaitlistParticipants) {\n              throw ctx.error(\"FORBIDDEN\", {\n                message: ERROR_CODES.MAX_PARTICIPANTS_REACHED,\n              });\n            }\n          }\n\n          if (opts.waitlistEndConfig.event === \"max-signups-reached\") {\n            if (count === null) {\n              count = await ctx.context.adapter.count({\n                model: model,\n              });\n            }\n            if (count >= opts.waitlistEndConfig.maximumSignups) {\n              const users = await getAllWaitlistUsers({\n                ctx,\n                modelName: model,\n              });\n              opts.waitlistEndConfig.onWaitlistEnd(users);\n              return;\n            }\n          } else if (opts.waitlistEndConfig.event === \"date-reached\") {\n            if (new Date() > opts.waitlistEndConfig.date) {\n              const users = await getAllWaitlistUsers({\n                ctx,\n                modelName: model,\n              });\n              opts.waitlistEndConfig.onWaitlistEnd(users);\n              return;\n            }\n          } else if (opts.waitlistEndConfig.event === \"trigger-function\") {\n            opts.waitlistEndConfig.triggerFunction(async () => {\n              const users = await getAllWaitlistUsers({\n                ctx,\n                modelName: model,\n              });\n              opts.waitlistEndConfig.onWaitlistEnd(users);\n              return;\n            });\n          }\n\n          const res = await ctx.context.adapter.create<WaitlistUserModified>({\n            model: model,\n            data: {\n              email,\n              name,\n              id: generateId(),\n              joinedAt: new Date(),\n              ...everythingElse,\n            },\n          });\n\n          return ctx.json(res);\n        },\n      ),\n      // removeWaitlistUser: createAuthEndpoint(\n      //   \"/waitlist/remove-user\",\n      //   {\n      //     method: \"POST\",\n      //     body: z.object({\n      //       email: z.string().email(),\n      //     }),\n      //   },\n      //   async (ctx) => {\n      //     const { email } = ctx.request.body;\n\n      //     const res = await ctx.context.adapter.delete({\n      //       model: model,\n      //       where: [{ field: \"email\", value: email, operator: \"eq\" }],\n      //     });\n\n      //     return ctx.json(res);\n      //   },\n      // ),\n    },\n  } satisfies BetterAuthPlugin;\n};\n\nfunction convertAdditionalFieldsToZodSchema(\n  additionalFields: Record<string, FieldAttribute>,\n) {\n  const additionalFieldsZodSchema: ZodRawShape = {};\n  for (const [key, value] of Object.entries(additionalFields)) {\n    let res: ZodTypeAny;\n\n    if (value.type === \"string\") {\n      res = z.string();\n    } else if (value.type === \"number\") {\n      res = z.number();\n    } else if (value.type === \"boolean\") {\n      res = z.boolean();\n    } else if (value.type === \"date\") {\n      res = z.date();\n    } else if (value.type === \"string[]\") {\n      res = z.array(z.string());\n    } else {\n      res = z.array(z.number());\n    }\n\n    if (!value.required) {\n      res = res.optional();\n    }\n\n    additionalFieldsZodSchema[key] = res;\n  }\n  return z.object(additionalFieldsZodSchema);\n}\n\nasync function getAllWaitlistUsers({\n  ctx,\n  modelName,\n  allUserCount,\n}: {\n  ctx: EndpointContext<\n    string,\n    {\n      method: \"POST\";\n      body: z.ZodObject<\n        z.ZodRawShape,\n        \"strip\",\n        z.ZodTypeAny,\n        {\n          [x: string]: any;\n        },\n        {\n          [x: string]: any;\n        }\n      >;\n    },\n    AuthContext\n  >;\n  modelName: string;\n  allUserCount?: number;\n}) {\n  allUserCount =\n    allUserCount ??\n    (await ctx.context.adapter.count({\n      model: modelName,\n    }));\n  const allUsers = await ctx.context.adapter.findMany<WaitlistUser>({\n    model: modelName,\n    limit: allUserCount,\n  });\n  return allUsers;\n}\n"
  ],
  "mappings": "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",
  "debugId": "A8BF0837AAF6AF5164756E2164756E21",
  "names": []
}